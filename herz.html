<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>FÃ¼r Greta â™¥</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; touch-action:none; }
        #canvas { display:block; width:100vw; height:100vh; image-rendering: pixelated; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        // 1:1-Ãœbersetzung der Python-Herzfunktion
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const CANVAS_WIDTH = canvas.width = window.innerWidth;
        const CANVAS_HEIGHT = canvas.height = window.innerHeight;
        const CENTER_X = CANVAS_WIDTH / 2;
        const CENTER_Y = CANVAS_HEIGHT / 2;
        const IMAGE_ENLARGE = 11;
        const HEART_COLOR = "#FFC0CB";

        // Originale Herzformel
        function heartFunction(t, shrinkRatio = IMAGE_ENLARGE) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            return {
                x: x * shrinkRatio + CENTER_X,
                y: y * shrinkRatio + CENTER_Y
            };
        }

        // Partikel-System wie im Python-Code
        class HeartParticleSystem {
            constructor() {
                this.points = [];
                this.edgePoints = [];
                this.centerPoints = [];
                this.allFrames = [];
                this.frameCount = 20;
                this.init();
            }

            init() {
                // Punkte auf Herz-Kurve
                for (let t = 0; t < 2 * Math.PI; t += 0.01) {
                    const {x, y} = heartFunction(t);
                    this.points.push({x, y});
                }

                // Diffusionspunkte
                this.points.forEach(point => {
                    for (let i = 0; i < 3; i++) {
                        this.edgePoints.push(this.scatter(point.x, point.y));
                    }
                });

                // Zentrumspunkte
                for (let i = 0; i < 5000; i++) {
                    const pt = this.points[Math.floor(Math.random() * this.points.length)];
                    this.centerPoints.push(this.scatter(pt.x, pt.y, 0.17));
                }

                // Alle Frames berechnen
                for (let f = 0; f < this.frameCount; f++) {
                    this.allFrames.push(this.calcFrame(f));
                }
            }

            scatter(x, y, beta = 0.15) {
                const ratioX = -beta * Math.log(Math.random());
                const ratioY = -beta * Math.log(Math.random());
                return {
                    x: x - ratioX * (x - CENTER_X),
                    y: y - ratioY * (y - CENTER_Y)
                };
            }

            calcFrame(frame) {
                const ratio = 25 * this.curve(frame / 10 * Math.PI);
                const particles = [];

                // Halo-Effekt
                for (let i = 0; i < 2000; i++) {
                    const t = Math.random() * 2 * Math.PI;
                    let {x, y} = heartFunction(t, 11.6);
                    const force = -1 / (Math.pow(x - CENTER_X, 2) + Math.pow(y - CENTER_Y, 2));
                    x += ratio * force * (x - CENTER_X);
                    y += ratio * force * (y - CENTER_Y);
                    particles.push({
                        x: x + Math.random() * 14 - 7,
                        y: y + Math.random() * 14 - 7,
                        size: Math.random() > 0.3 ? 2 : 1
                    });
                }

                // Hauptpunkte
                this.points.forEach(pt => {
                    const pos = this.calcPosition(pt.x, pt.y, ratio);
                    particles.push({
                        x: pos.x,
                        y: pos.y,
                        size: Math.floor(Math.random() * 3) + 1
                    });
                });

                return particles;
            }

            calcPosition(x, y, ratio) {
                const force = 1 / Math.pow(Math.pow(x - CENTER_X, 2) + Math.pow(y - CENTER_Y, 2), 0.52);
                return {
                    x: x - (ratio * force * (x - CENTER_X) + Math.random() * 2 - 1),
                    y: y - (ratio * force * (y - CENTER_Y) + Math.random() * 2 - 1)
                };
            }

            curve(p) {
                return 2 * (2 * Math.sin(4 * p)) / (2 * Math.PI);
            }
        }

        // Animation starten
        const system = new HeartParticleSystem();
        let frame = 0;

        function animate() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Header-Text
            ctx.font = "bold 30px 'Courier New', monospace";
            ctx.fillStyle = "pink";
            ctx.textAlign = "center";
            ctx.fillText("GRETA, ALLES GUTE ZUM 17! ðŸ’—", CENTER_X, 50);
            
            // Partikel zeichnen
            ctx.fillStyle = HEART_COLOR;
            const particles = system.allFrames[frame % system.frameCount];
            particles.forEach(p => {
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            
            frame++;
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
